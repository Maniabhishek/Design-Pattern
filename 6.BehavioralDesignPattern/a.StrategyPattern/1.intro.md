### What is it?
- Strategy Pattern lets you define a family of algorithms, put each one in a separate class, and make them interchangeable at runtime.

### In simple words:
- ğŸ‘‰ Same task, different ways of doing it
- ğŸ‘‰ Choose the way at runtime
- ğŸ‘‰ No if / else / switch mess

### Real-World Example (Very Intuitive)
#### Scenario: Travel App (Google Maps / Uber)
- You want to go from A â†’ B.
- Possible strategies:
  - ğŸš— Car
  - ğŸš² Bike
  - ğŸšŒ Bus
  - ğŸš¶ Walk

- Destination is same.
- Only strategy changes.

### Without Strategy Pattern (Bad Design)
```ts
class Navigator {
  navigate(mode: string) {
    if (mode === "car") {
      console.log("Navigating by car");
    } else if (mode === "bike") {
      console.log("Navigating by bike");
    } else if (mode === "walk") {
      console.log("Navigating by walking");
    }
  }
}

```

### above code has Problems
- Violates OCP
- Hard to extend
- Hard to test
- Grows endlessly

### Strategy Pattern Design
- Step 1ï¸âƒ£: Create the Strategy interface
```ts
interface NavigationStrategy {
  navigate(): void;
}
```

- step 2ï¸âƒ£: Implement different strategies
```ts
class CarStrategy implements NavigationStrategy {
  navigate() {
    console.log("Navigating by car");
  }
}

class BikeStrategy implements NavigationStrategy {
  navigate() {
    console.log("Navigating by bike");
  }
}

class WalkStrategy implements NavigationStrategy {
  navigate() {
    console.log("Navigating by walking");
  }
}
```

- Step 3ï¸âƒ£: Context class (uses strategy)
```ts
class Navigator {
  constructor(private strategy: NavigationStrategy) {}

  setStrategy(strategy: NavigationStrategy) {
    this.strategy = strategy;
  }

  navigate() {
    this.strategy.navigate();
  }
}
```

Step 4ï¸âƒ£: Use it (runtime switching)
```ts
const navigator = new Navigator(new CarStrategy());
navigator.navigate(); // car

navigator.setStrategy(new BikeStrategy());
navigator.navigate(); // bike

navigator.setStrategy(new WalkStrategy());
navigator.navigate(); // walk

```

### Why This Is Powerful
- âœ” No conditionals
- âœ” Easy to add new strategy
- âœ” Follows OCP + DIP
- âœ” Runtime flexibility

### Real Backend Example (Payments)
- Problem:
  - Same payment flow, different payment methods.
```ts
interface IPayment {
    pay(): void
}

class CardPayment implements IPayment {
    pay(){
        console.log('card payment')
    }
}

class WalletPayment implements IPayment {
    pay(){
        console.log('wallet payment')
    }
}

class PaymentService {
    payment:IPayment 
    constructor(payment: IPayment){
        this.payment = payment
    }

    setPaymentStrategy(payment: IPayment){
        this.payment = payment
    }

    pay(){
        this.payment.pay()
    }
}

export function CallPaymentService(){
    const cardPayment = new CardPayment()

    const ps = new PaymentService(cardPayment)

    ps.pay()

    ps.setPaymentStrategy(new WalletPayment())
    ps.pay()

}


```

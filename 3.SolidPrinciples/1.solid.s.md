## Single Responsibility Principle
- SOLID is a mnemonic for five design principles intended to make software designs more understandable, flexible and maintainable.
- A class should have just one reason to change
- Try to make every class responsible for a single part of the functionality provided by the software, and make that responsibility entirely encapsulated by (you can also say hidden with in) the class.
- The main goal of this principle is reducing complexity. You don‚Äôt need to invent a sophisticated design for a program that only has about 200 lines of code. Make a dozen methods pretty, and you‚Äôll be fine.
- The real problems emerge when your program constantly grows and changes. At some point classes become so big that you can no longer remember their details. Code navigation slows down to a crawl, and you have to scan through whole classes or even an entire program to find specific things. The number of entities in program overflows your brain stack, and you feel that you‚Äôre losing control over the code.
- There‚Äôs more: if a class does too many things, you have to change it every time one of these things changes. While doing that, you‚Äôre risking breaking other parts of the class which you didn‚Äôt even intend to change.
- In Example we can see the first class that we made has multiple methods where we calculating price, printing , saving to db, so there were many reasons to change
- then we created some seperate class to do db related stuffs then for pritning invoice now these individual classes have single responsibility to be changed
- If you feel that it‚Äôs becoming hard to focus on specific aspects of the program one at a time, remember the single responsibility principle and check whether it‚Äôs time to divide some classes into parts. 



- long story short A class should have only ONE reason to change.

### wrong 
- a class should do only one thing

### Right
- a class should change for only one business reason

### Real-World Analogy
## Bad SRP
- A Restaurant Manager:
  - Takes orders
  - Cooks food
  - Cleans tables
  - Handles billing
- If cooking rules change ‚Üí manager changes
- If billing rules change ‚Üí manager changes
- üëâ Multiple reasons to change = SRP violation

## ‚úÖ Good SRP
- Waiter ‚Üí takes orders
- Chef ‚Üí cooks
- Cashier ‚Üí billing
- Each role changes for one reason only

### Clear SRP violation
```ts
class UserService {
  createUser(user: any) {
    // business logic
    console.log("User created");
  }

  saveToDatabase(user: any) {
    console.log("Saved to DB");
  }

  sendWelcomeEmail(user: any) {
    console.log("Email sent");
  }
}

```

### ‚ùå What‚Äôs wrong in the above code ?
- This class has 3 responsibilities:
  - Business logic (user creation)
  - Persistence (DB)
  - Communication (email)

### ‚ùóReasons to change:
- Database changes (MySQL ‚Üí Mongo)
- Email provider changes
- User creation rules change
SRP(Single responsibility principle) broken in above scenario

```ts
class UserRepository {
  save(user: any) {
    console.log("Saved to DB");
  }
}

class EmailService {
  sendWelcomeEmail(user: any) {
    console.log("Email sent");
  }
}

class UserService {
  constructor(
    private userRepo: UserRepository,
    private emailService: EmailService
  ) {}

  createUser(user: any) {
    this.userRepo.save(user);
    this.emailService.sendWelcomeEmail(user);
    console.log("User created");
  }
}
```

### Why above code follows SRP

| Class          | Responsibility      |
| -------------- | ------------------- |
| UserService    | User business rules |
| UserRepository | Persistence         |
| EmailService   | Communication       |
